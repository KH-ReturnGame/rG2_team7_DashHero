using UnityEngine;
using System.Collections;

public class PlayerMove : MonoBehaviour
{   //ï¿½Ìµï¿½ï¿½ï¿½ï¿½ï¿½

    public float MoveSpeed = 6f;
    private Rigidbody2D rb;
    private float MoveInput;

    //ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½

    public float jumpImpulse = 12f;//ï¿½ï¿½ï¿½ï¿½ ï¿½Ù´ï¿½ ï¿½ï¿½
    public Transform groundCheck; // player ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ®ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½Ä¡
    public float groundCheckRadius = 0.18f; // ï¿½Ù´ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½ï¿½(ï¿½ï¿½Æ®ï¿½Ú½ï¿½ ï¿½ï¿½ï¿½ï¿½) Radiusï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
    public LayerMask groundLayer; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ 'ï¿½Ù´ï¿½'ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½Ì¾ï¿½ ï¿½ï¿½ï¿½ï¿½)


    //ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ (ï¿½ï¿½ï¿½ß¿ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½)
    public float dashSpeed = 18f; // ï¿½ë½¬ ï¿½Óµï¿½
    public float dashTime = 0.15f; // ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ï¿½Ç´ï¿½ ï¿½Óµï¿½ Âªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
    public float dashCooldown = 0.5f; //ï¿½ë½¬ ï¿½ï¿½Å¸ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½

    public int maxAirDashCount = 1; // ï¿½ï¿½ï¿½ß¿ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½

    private bool isDashing = false; // ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ï¿½ï¿½ï¿½Î°ï¿½(ï¿½ë½¬ï¿½ï¿½ï¿½Ì¸ï¿½ ï¿½Ù¸ï¿½ ï¿½Úµï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Èµï¿½)
    private bool canDash = true; // ï¿½ë½¬ ï¿½ï¿½Å¸ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ È®ï¿½ï¿½
    private int airDashCount = 0; // ï¿½ï¿½ï¿½ß¿ï¿½ï¿½ï¿½ ï¿½Ì¹ï¿½ ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½Â°ï¿½

    private int facingDir = 1; //ï¿½Ã·ï¿½ï¿½Ì¾ï¿½ ï¿½Ù¶óº¸´ï¿½ ï¿½ï¿½ï¿½ï¿½
    
    public Camera cam;

    // [ï¿½ß°ï¿½] ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½Úµï¿½ ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
    // =======================

    public Transform attackPoint;       // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½Ã·ï¿½ï¿½Ì¾ï¿½ ï¿½ï¿½ï¿½ï¿½ Empty ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ®)
    public float attackRadius = 0.45f;  // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)
    public LayerMask enemyLayer;        // ï¿½ï¿½ ï¿½ï¿½ï¿½Ì¾ï¿½(Enemy ï¿½ï¿½ï¿½Ì¾ï¿½)
    public int dashAttackDamage = 1;    // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½



    void Start()
    {
        rb = GetComponent<Rigidbody2D>();

    }
    void Update()
    {
        float move = Input.GetAxisRaw("Horizontal");

        float leftLimit =
            cam.transform.position.x
            - cam.orthographicSize * cam.aspect;

        Vector3 pos = transform.position;

        // ğŸ”¥ ì™¼ìª½ ê²½ê³„ì— ìˆê³ , ì™¼ìª½ìœ¼ë¡œ ê°€ë ¤ í•˜ë©´ ì´ë™ ì°¨ë‹¨
        if (pos.x <= leftLimit && move < 0)
        {
            move = 0;
        }

        // ì´ë™
        pos.x += move * MoveSpeed * Time.deltaTime;
        transform.position = pos; //GetAxisRawï¿½ï¿½ -1,0,1ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½

        // [ï¿½ß°ï¿½] ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½  MoveInput : ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ì¸ï¿½
        // MoveInputï¿½ï¿½ 0ï¿½ï¿½ ï¿½Æ´ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
        // (ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ù¶ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ï¿½Ï·ï¿½ï¿½ï¿½)

        if (MoveInput != 0)  
        {
            facingDir = (MoveInput > 0) ? 1 : -1;
        }

        // [ï¿½ß°ï¿½] ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ È½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
        // ï¿½ï¿½ï¿½ï¿½ï¿½ß´Ù°ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï¸ï¿½ ï¿½Ù½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ 1È¸ï¿½ï¿½ "ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½
     
        if (IsGrounded())
        {
            airDashCount = 0;
        }
        // [ï¿½ß°ï¿½] ï¿½ë½¬ ï¿½Ô·ï¿½ (LeftShift)
        // ï¿½ï¿½ï¿½ï¿½:
        // 1) ï¿½ï¿½Å¸ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½(canDash)
        // 2) ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ ï¿½Æ´ï¿½(!isDashing)
        // 3) ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ È½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½(airDashCount < maxAirDashCount)
        
        if (Input.GetKeyDown(KeyCode.LeftShift))
        {
            if (canDash && !isDashing && airDashCount < maxAirDashCount)
            {
                StartCoroutine(Dash()); // ï¿½Ú·ï¿½Æ¾ï¿½ï¿½ï¿½ï¿½ "ï¿½ë½¬ ï¿½Ã°ï¿½/ï¿½ï¿½Å¸ï¿½ï¿½" ï¿½ï¿½ï¿½ï¿½ [Dash ï¿½Ú·ï¿½Æ¾] : "ï¿½Ã°ï¿½ï¿½ï¿½ ï¿½å¸£ï¿½ï¿½ ï¿½àµ¿"ï¿½ï¿½ Ã³ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½Ô¼ï¿½
                                        // =====================================
                                        // ï¿½Ú·ï¿½Æ¾ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ô¼ï¿½Ã³ï¿½ï¿½ ï¿½Ù·ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ê°ï¿½,
                                        // ï¿½ß°ï¿½ï¿½ß°ï¿½ "ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Ù°ï¿½(ï¿½ï¿½Ù·È´Ù°ï¿½) ï¿½Ù½ï¿½ ï¿½Ì¾î¼­ ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ ï¿½ï¿½ ï¿½Ö¾ï¿½.
            }
        }


        // ï¿½ï¿½ï¿½ï¿½ Å°ï¿½ï¿½ "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½" ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ true (ï¿½âº» Jumpï¿½ï¿½ Space)
        // + ï¿½Ù´Ú¿ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ 
        Debug.Log(IsGrounded());
        if (Input.GetButtonDown("Jump") && IsGrounded())
        {
            Jump();
        }


    }
    void FixedUpdate()

    {  // [ï¿½ß°ï¿½] ï¿½ë½¬ ï¿½ß¿ï¿½ï¿½ï¿½ ï¿½Ìµï¿½ ï¿½Úµå¸¦ ï¿½ï¿½ï¿½ï¿½ï¿½Ï¸ï¿½ ï¿½ï¿½ ï¿½ï¿½!
        // ï¿½ï¿½ï¿½ï¿½ï¿½Ï¸ï¿½ rb.linearVelocityï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½á¼­ ï¿½ë½¬ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Å³ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
        if (isDashing) return;

        rb.linearVelocity = new Vector2(MoveInput * MoveSpeed, rb.linearVelocity.y);//ï¿½ï¿½ï¿½ï¿½ï¿½Ö´ï¿½ ï¿½Ó·ï¿½

    }

    void Jump()
    {         // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Æ·ï¿½ ï¿½Óµï¿½ï¿½ï¿½ 0ï¿½ï¿½ï¿½ï¿½ ï¿½Ê±ï¿½È­ï¿½ï¿½ ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½)
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, 0f);
               // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½!
        rb.AddForce(Vector2.up * jumpImpulse, ForceMode2D.Impulse);
        // ï¿½ï¿½ï¿½ï¿½ Å©ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½, ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½î¶»ï¿½ï¿½ ï¿½Ö´ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ // ForceMode2D.Impulse:ï¿½ï¿½ ï¿½Ñ¼ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½Ö´Â°ï¿½
    }
 
    IEnumerator Dash()
    { 
    // [ï¿½ß°ï¿½] ï¿½ë½¬ ï¿½Ú·ï¿½Æ¾ ï¿½Ô¼ï¿½
    // ï¿½Ú·ï¿½Æ¾(Coroutine) = "ï¿½Ã°ï¿½ï¿½ï¿½ ï¿½É¸ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ Ã³ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½ï¿½ï¿½ï¿½Æ¼ ï¿½ï¿½ï¿½
    // ï¿½ï¿½) ï¿½ë½¬:
    // 1) ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½
    // 2) 0.15ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
    // 3) ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½
    // 4) 0.5ï¿½ï¿½ ï¿½ï¿½Å¸ï¿½ï¿½
    //
    // ï¿½Ì·ï¿½ ï¿½å¸§ï¿½ï¿½ ï¿½Ï¹ï¿½ ï¿½Ô¼ï¿½(void Dash())ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ "ï¿½ï¿½Ù¸ï¿½ï¿½ï¿½"ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï±ï¿½ ï¿½ï¿½Æ´ï¿½.
    // ï¿½×·ï¿½ï¿½ï¿½ ï¿½Ú·ï¿½Æ¾ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½, ï¿½Ú·ï¿½Æ¾ï¿½ï¿½ ï¿½ï¿½È¯ï¿½ï¿½ï¿½ï¿½ IEnumeratorï¿½ï¿½ ï¿½Ø¾ï¿½ ï¿½Ñ´ï¿½.
    //
    // ï¿½ï¿½ IEnumeratorï¿½ï¿½ 'ï¿½Ô¼ï¿½'ï¿½ï¿½ ï¿½Æ´Ï¶ï¿½ 'ï¿½ï¿½È¯ï¿½ï¿½(ï¿½Ú·ï¿½ï¿½ï¿½)'ï¿½Ì´ï¿½.
    // "ï¿½ï¿½ ï¿½Ô¼ï¿½ï¿½ï¿½ ï¿½Ú·ï¿½Æ¾ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½Ö´ï¿½"ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Æ¼ï¿½ï¿½ ï¿½Ë·ï¿½ï¿½Ö´ï¿½ ï¿½ï¿½ï¿½ï¿½.
    //
    // ï¿½Ú·ï¿½Æ¾ï¿½ï¿½ StartCoroutine(Dash()); ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ø¾ï¿½ ï¿½Ñ´ï¿½
    
        // ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ È½ï¿½ï¿½ 1È¸ ï¿½ï¿½ï¿½ï¿½
        // (ï¿½ï¿½ï¿½ß¿ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ï·ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½)
        airDashCount++;

        // ï¿½ï¿½Å¸ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½: ï¿½ë½¬ ï¿½ï¿½ï¿½
        canDash = false;

        // ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Â·ï¿½ ï¿½ï¿½ï¿½ï¿½
        isDashing = true;

        // ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½:
        // - ï¿½Ô·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬
        // - ï¿½Ô·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ù¶ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬
        int dashDir = facingDir;
        if (MoveInput != 0)
        {
            dashDir = (MoveInput > 0) ? 1 : -1;
        }

        // dashDir == 1  : ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ O
        // dashDir == -1 : ï¿½ï¿½ï¿½ï¿½ È¸ï¿½ï¿½ ï¿½ë½¬ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ X
        if (dashDir == 1)
        {
            DoDashAttack();
        }

        // ï¿½ë½¬ï¿½ï¿½ "È®ï¿½ï¿½ï¿½Ï°ï¿½" ï¿½ï¿½ï¿½Ì°ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ß·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
        // (ï¿½ï¿½ï¿½ï¿½ ï¿½ë½¬ï¿½ï¿½ ï¿½Æ·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½é¼­ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½)
        float originalGravity = rb.gravityScale; // ï¿½ï¿½ï¿½ï¿½ ï¿½ß·ï¿½ ï¿½ï¿½ï¿½ï¿½
        rb.gravityScale = 0f;                    // ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ ï¿½ß·ï¿½ 0

        // ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Óµï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ö±ï¿½
        // yï¿½ï¿½ 0ï¿½ï¿½ï¿½ï¿½ ï¿½Ø¼ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ç¹«ï¿½ï¿½ï¿½ï¿½ 'ï¿½ï¿½' ï¿½ï¿½ï¿½ï¿½)
        rb.linearVelocity = new Vector2(dashDir * dashSpeed, 0f);

        // dashTime ï¿½ï¿½Å­ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½
        yield return new WaitForSeconds(dashTime);

        // ï¿½ß·ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
        rb.gravityScale = originalGravity;

        // ï¿½ë½¬ ï¿½ï¿½
        isDashing = false;

        // ï¿½ï¿½Å¸ï¿½ï¿½ ï¿½ï¿½Ù¸ï¿½ï¿½ï¿½
        yield return new WaitForSeconds(dashCooldown);

        // ï¿½ï¿½Å¸ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ ï¿½Ù½ï¿½ ï¿½ë½¬ ï¿½ï¿½ï¿½ï¿½
        canDash = true;
    }



    void DoDashAttack()
    {
        // attackPoint ï¿½ï¿½Ä¡ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½×·ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ Ã£ï¿½ï¿½
        Collider2D[] hits = Physics2D.OverlapCircleAll(
            attackPoint.position,
            attackRadius,
            enemyLayer
        );

        // Ã£ï¿½ï¿½ ï¿½ï¿½ï¿½é¿¡ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½Ö±ï¿½
        foreach (Collider2D hit in hits)
        {
            // ï¿½ï¿½ï¿½ï¿½ EnemyHealth ï¿½ï¿½Å©ï¿½ï¿½Æ®ï¿½ï¿½ ï¿½Ù¾ï¿½ï¿½Ö´Ù´ï¿½ ï¿½ï¿½ï¿½ï¿½!
            EnemyHealth enemy = hit.GetComponent<EnemyHealth>();
            if (enemy != null)
            {
                enemy.TakeDamage(dashAttackDamage);
            }
        }
    }
    // ï¿½ß¹Ù´ï¿½ ï¿½ï¿½Ã³ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½×·ï¿½ï¿½ï¿½ "Ground" ï¿½ï¿½ï¿½Ì¾ï¿½ï¿½ ï¿½ï¿½Ä¡ï¿½ï¿½ 'ï¿½Ù´ï¿½'ï¿½Ì¶ï¿½ï¿½ ï¿½Ç´ï¿½
    bool IsGrounded()
    {
    return Physics2D.OverlapCircle(groundCheck.position, groundCheckRadius, groundLayer);
        // 
    }
    // ï¿½ï¿½ï¿½ï¿½ï¿½Í¿ï¿½ï¿½ï¿½ ï¿½Ù´ï¿½ Ã¼Å© ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Ì°ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)
    void OnDrawGizmosSelected()
    {
        if (groundCheck == null) return;
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(groundCheck.position, groundCheckRadius); //DraWireSphere:ï¿½ï¿½ï¿½ï¿½ï¿½Îµï¿½ ï¿½ï¿½Ã¼ï¿½ï¿½ ï¿½ï¿½ï¿½ä¿¡ ï¿½×¸ï¿½ï¿½ï¿½
    }

}

